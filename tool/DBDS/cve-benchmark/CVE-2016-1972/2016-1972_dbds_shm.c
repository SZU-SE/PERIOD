#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>
#include <time.h>
#include <sys/shm.h>
#include "../../sched.h"

const int N1 = 2;
const int N2 = 3;

// F: code blocks annotated with "// F:" are introduced to guide fuzzing
typedef struct Sched_Info {
    int N;			// number of threads concerned
    int M;			// number of kep points per thread
    int kp[10000];	// how many times should a thread yield before a kp
} sched_info;

// F: the information used to guide the scheduling
sched_info * si;


// #define TEST_TIME
static pthread_mutex_t* lock;

void Inc(long *num)
{
    ++(*num);
}

long Dec(long *num)
{
    return --(*num);
}

void Enter(pthread_mutex_t* l)
{
    pthread_mutex_lock(l);
}

void Exit(pthread_mutex_t* l)
{
    pthread_mutex_unlock(l);
}

void * once()
{   
	while(get_tid_to_run() == 0);		// F: wait until its his turn
    int sched_tid = get_tid_to_run();	// F: acquire the tid for sechduling
    set_tid_to_run(0);					// F: notify main thread to run
	
	// F: set the thread to use deadline scheduling
    set_sched_dl(1000 * 1000, 1000 * 1000 * 10, 1000 * 1000 * 10);
    int idx_kp = (sched_tid - 1) * (si -> M);
	
    static long waiters = 0;
    static int done = 0;

	// F: give up several circles' time
	while(1) {
		//printf("t_%d: %d times to yield at KP %d.%d\n", sched_tid, si -> kp[idx_kp], sched_tid, idx_kp - (sched_tid - 1) * (si -> M));
		if(si -> kp[idx_kp] <= 0) break;
		sched_yield();
		si -> kp[idx_kp]--;
	}
	idx_kp++;
	
    if(done)			// KP 1
        return 0;

	// F: give up several circles' time
	while(1) {
		//printf("t_%d: %d times to yield at KP %d.%d\n", sched_tid, si -> kp[idx_kp], sched_tid, idx_kp - (sched_tid - 1) * (si -> M));
		if(si -> kp[idx_kp] <= 0) break;
		sched_yield();
		si -> kp[idx_kp]--;
	}
	idx_kp++;
	
	Inc(&waiters);		// KP 2
	
    Enter(lock);		
    printf("Enter\n");

    if(!done)
    {
        done = 1;
    }

    printf("Exit\n");

    Exit(lock);
	
	// F: give up several circles' time
	while(1) {
		//printf("t_%d: %d times to yield at KP %d.%d\n", sched_tid, si -> kp[idx_kp], sched_tid, idx_kp - (sched_tid - 1) * (si -> M));
		if(si -> kp[idx_kp] <= 0) break;
		sched_yield();
		si -> kp[idx_kp]--;
	}
	idx_kp++;
		
    if(!Dec(&waiters))	// KP 3
    {
		printf("After  Decrement waiters = %ld\n", waiters);
        printf("free lock\n");
		
		// F: give up several circles' time
        while(1) {
            //printf("t_%d: %d times to yield at KP %d.%d\n", sched_tid, si -> kp[idx_kp], sched_tid, idx_kp - (sched_tid - 1) * (si -> M));
            if(si -> kp[idx_kp] <= 0) break;
            sched_yield();
            si -> kp[idx_kp]--;
        }
        idx_kp++;
		
        free(lock);		// KP 4
		
		// F: give up several circles' time
        while(1) {
            //printf("t_%d: %d times to yield at KP %d.%d\n", sched_tid, si -> kp[idx_kp], sched_tid, idx_kp - (sched_tid - 1) * (si -> M));
            if(si -> kp[idx_kp] <= 0) break;
            sched_yield();
            si -> kp[idx_kp]--;
        }
        idx_kp++;
		
        lock = NULL;	// KP 5
    }
}

#define thread_size 2

int main()
{
	// F: set up the yield patten using shared memory
	int shmid;
    key_t key = 2222;
    // Setup shared memory
    if ((shmid = shmget(key, sizeof(sched_info), IPC_CREAT | 0666)) < 0) {
        printf("Error getting shared memory id. 1\n");
        exit(1);
    }
	// Attached shared memory
    if ((sched_info *) -1 == (si = shmat(shmid, NULL, 0))) {
        printf("Error attaching shared memory id. 2\n");
        exit(1);
    }

    // for(int i = 0; i < 20; i++)
    //     printf("%d ", si -> kp[i]);
    // printf("\n");

	set_tid_to_run(0);	// F: allow the main thread to run
	int c_tid = 0;		// F: child tid, initially 0
	
	lock = malloc(sizeof(pthread_mutex_t));
#ifdef TEST_TIME
    static double run_time_begin;
    static double run_time_end;
    static double run_time_total;
    run_time_begin = clock();
#endif
    pthread_t t[thread_size];

    for(int i = 0; i < thread_size;)
    {
        while(get_tid_to_run() != 0);	// F: wait until its his turn
		c_tid++;						// F: get the next child tid
		set_tid_to_run(c_tid);			// F: notify thread 1 to get ready
	
		pthread_create(&t[i], NULL, once, NULL);
        
		while(get_tid_to_run() != 0);	// F: wait until its his turn
		c_tid++;						// F: get the next child tid
		set_tid_to_run(c_tid);			// F: notify thread 1 to get ready
	
		pthread_create(&t[i+1], NULL, once, NULL);
        i += 2;
    }

    struct timeval start, end;
    gettimeofday( &start, NULL );

    for(int i = 0; i < thread_size;)
    {
        pthread_join(t[i+1], NULL);
		pthread_join(t[i], NULL);
        i += 2;
    }

    gettimeofday( &end, NULL );
    int timeuse = 1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec -start.tv_usec;
    //printf("time: %d us\n", timeuse);

    printf("\nprogram-successful-exit\n");
#ifdef TEST_TIME
    run_time_end = clock();
    run_time_total = run_time_end - run_time_begin;
    printf("test-the-total-time: %.3lf\n", (double)(run_time_total/CLOCKS_PER_SEC)*1000);
#endif
    return 0;
}
