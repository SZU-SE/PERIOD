#!/usr/bin/env python3

# This is the structrue of Share Memory class
SHARE_THREAD_NUM = 100
SHARE_ARRAY_SIZE = 1990
# typedef struct Sched_Info {
#	uint64_t time;										// the execution time of the program (nsec)
#	unsigned int N;										// number of threads concerned
#	unsigned int M;										// number of kep points per thread
#	unsigned int TestedPeriod;							// It took several period in testing engine
#	unsigned int kpNumArray[SHARE_MEMORY_THREAD_NUM];	// the specific kpNum of each My_tid Thread, only consider almost 10 thread
#	unsigned int kp[SHARE_MEMORY_ARRAY_SIZE];			// how many times should a thread yield before a kp
#	unsigned int kpLoc[SHARE_MEMORY_ARRAY_SIZE];		// the hash ID of Key Point
#	unsigned int kpOrder[SHARE_MEMORY_ARRAY_SIZE];		// recored the order of key points
# } sched_info;

# =================================================================================

import sys, subprocess, time, interleaving, os, getopt, copy, signal
from external_def import get_ASAN_error_type, formateTime, filled_with_zero, calculate_coverage_hashID, add_to_explore_dict, print_Info_from_shm, doesZeroInList
from collections import OrderedDict
from datetime import datetime
from ast import literal_eval
from ctypes import *
from interleaving import *
from itertools import combinations, permutations
import numpy as np

DebugInfo = False                   # Set “True”, if you want to get debug information

FILE_SAVED_MAXNUM =  10000          # The max number of error interleavings we can saved
subprocessTimeout = 5
rlts = []                           # the set of unique results generated by the c program
statusL = []                        # the set of unique status generated by the c program
startTime = time.time()
lastTime  = time.time()             # the time when a new result is found
rounds = lastRound = 0
output_num = [0]                    # the number of different outputs
total_errors_interleavings = [0]    # the number of errors
total_timeouts_interleavings = [0]  # the number of timeouts
recordERR = 1
check_STDOUT = 1                    # Set 2 if you want to record diff result
check_STDERR = 1                    # Set 1 if you want to record err result
kpMaxNumArray = [0]*SHARE_THREAD_NUM
parentArray = [0]*SHARE_THREAD_NUM

def setup_share_memroy():
    IPC_KEY, MAP_SIZE, IPC_CREAT, IPC_EXCL = 1111, sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM+3*SHARE_ARRAY_SIZE), 512, 1024
    shmget = cdll.LoadLibrary("libc.so.6").shmget
    shmat = cdll.LoadLibrary("libc.so.6").shmat
    shmat.restype = c_void_p
    shm_id = shmget(IPC_KEY, MAP_SIZE, IPC_CREAT | IPC_CREAT | 0o666)
    ADDR = shmat(shm_id, 0, 0)
    return ADDR

def get_info_from_share_memory(P=None, A=None, B=None, T=None, kpNumArray=None, kpYieldArray=None, kpLocArray=None, kpOrderArray=None):
    if P != None:
        memmove(byref(P), ADDR, sizeof(c_ulonglong))
    if A != None:
        memmove(byref(A), ADDR + sizeof(c_ulonglong), sizeof(c_uint))
    if B != None:
        memmove(byref(B), ADDR + sizeof(c_ulonglong) + sizeof(c_uint), sizeof(c_uint))
    if T != None:
        memmove(byref(T), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, sizeof(c_uint))
    if kpNumArray != None:
        memmove(byref(kpNumArray), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*3, sizeof(c_uint)*SHARE_THREAD_NUM)
    if kpYieldArray != None:
        memmove(byref(kpYieldArray), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM), sizeof(c_uint)*SHARE_ARRAY_SIZE)
    if kpLocArray != None:
        memmove(byref(kpLocArray), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM+SHARE_ARRAY_SIZE), sizeof(c_uint)*SHARE_ARRAY_SIZE)
    if kpOrderArray != None:
        memmove(byref(kpOrderArray), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM+2*SHARE_ARRAY_SIZE), sizeof(c_uint)*SHARE_ARRAY_SIZE)

def memmove_pattern_list(PatternList):
    tmp = []
    for t in PatternList:
        tmp += t
    tmparr = (c_uint * len(tmp))(*tmp)
    memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM), tmparr, sizeof(c_uint) * len(tmp))

# create subprocess according to the value of check_STDOUT and check_STDERR
def create_DBDS_subprocess(check_STDOUT, check_STDERR):
    if (check_STDOUT >= 1 and check_STDERR == 1):
        process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    elif (check_STDOUT >= 1 and check_STDERR == 0):
        process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp, stdout=subprocess.PIPE)
    elif (check_STDOUT == 0 and check_STDERR == 1):
        process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp, stderr=subprocess.PIPE)
    else:
        process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp)
    return process

# save the error message
def record_error_message(process, folder_name, stdoutdata, stderrdata, pattern, rounds):
    
    CrashType, CrashDesc = get_ASAN_error_type(stderrdata)
    
    lastFlag = 0
    if(not process.returncode in statusL): # stderr
        statusL.append(process.returncode)
        lastFlag = 1

    if(process.returncode!=0 and process.returncode!=1 and process.returncode!=-11): #save result
        if total_errors_interleavings[0] < FILE_SAVED_MAXNUM:
            total_errors_interleavings[0] = total_errors_interleavings[0] + 1
            lastFlag = 1
            print("\033[31m\t[Error Found]: NO." + str(total_errors_interleavings[0]) + " " + CrashType + "\033[0m")
            err_file_name = folder_name + "/" + "Errors" + "/" + str(format(total_errors_interleavings[0],"0>6")) + "_" + str(format(rounds,"0>7")) + "_" + CrashType.replace(' ', '-')
            with open (err_file_name,"wb") as errfile:
                errfile.write(bytes(str(pattern)+"\n", encoding = "utf8"))
                if check_STDERR == 1:
                    errfile.write(stderrdata)
            print("\033[31m\tThe interleavings saved in", err_file_name, "\033[0m")
    elif(check_STDOUT > 1 and not stdoutdata in rlts): # stdout
        if output_num[0] < FILE_SAVED_MAXNUM:
            output_num[0] = output_num[0] + 1
            lastFlag = 1
            rlts.append(stdoutdata)
            out_file_name = folder_name+"/"+"DiffResult"+"/"+str(format(output_num[0],"0>6"))
            with open (out_file_name,"wb") as outfile:
                outfile.write(bytes(str(pattern)+"\n", encoding = "utf8"))
                outfile.write(stdoutdata)
        
    if(lastFlag == 1): # last Round
        lastRound = rounds
        lastTime = time.time()

# save the timeout message
def record_timeout_message(folder_name, pattern):
    if total_timeouts_interleavings[0] < FILE_SAVED_MAXNUM:
        total_timeouts_interleavings[0] = total_timeouts_interleavings[0] + 1
        print("\033[33m\t[Timeout " + str(subprocessTimeout) + "]: NO." + str(total_timeouts_interleavings[0]) + "\033[0m")
        timeout_file_name = folder_name+"/"+"Timeouts"+"/"+str(format(total_timeouts_interleavings[0],"0>6"))
        with open (timeout_file_name,"wb") as timeoutfile:
            timeoutfile.write(bytes(str(pattern)+"\n", encoding = "utf8"))
            if check_STDERR == 1:
                timeoutfile.write(bytes("Timeout = " + str(subprocessTimeout), encoding = "utf8"))
        print("\033[33m\tunder interleavings saved in", timeout_file_name, "\033[0m")

def check_and_update_kpNumMaxArray(kpNumArray):
    hasNewMax = False
    for i in range(0,N):
        if kpNumArray[i] > kpMaxNumArray[i]:
            kpMaxNumArray[i] = kpNumArray[i]
            hasNewMax = True
    return hasNewMax

def new_max_kpNumArray(kpNumArray, parentArray):
    hasNewMax = False
    for i in range(0,N):
        if kpNumArray[i] > parentArray[i]:
            parentArray[i] = kpNumArray[i]
            hasNewMax = True
    return hasNewMax

def get_period(inter):
    period = 1
    com = inter[0]
    for each in inter:
        if each == com:
            continue
        else:
            com = each
            period = period + 1
    return period

def compare_period(inter, p):
    ret = True
    period = 1
    com = inter[0]
    for each in inter:

        if each == com:
            continue
        else:
            com = each
            period = period + 1
        
        if period > p:
            ret = False
            break
        
    return ret

# ================= Start Parameter processing phase ========================

# get argv and check whether the task is reproducing a certain interleaving
reproduceFile = "" # the file that saves thread interleavings that can trigger errors.
memInfoFile = "" #  the file that saves memory group Info
varNumConsidered = 0 # Number of variables considered
bugDepth = 2 # Limit the maximum number of bug depth (defaut: 2)
period_limit = bugDepth + 1 # Limit the maximum number of period (defaut: 3)
memPairConsidered = 0 # Number of mempairs considered
skipEnter = 0 # It doesn't need to press enter to advance automatically
runs_limit = 0
TaskReproduce = 0
LoadMemInfoFile = 0
period_save = period_limit
enableMemoryLeak = 0
opts = []
args = []
try:
    opts, args = getopt.getopt(sys.argv[1:], "hlyor:m:n:d:t:f:", ["help", "skip-enter", "enable-memoryleak", "overhead-testing", "reproduceFile=", "memPairConsidered=", "varNumConsidered=", "bugDepth=", "timeout=", "runs="])
except getopt.GetoptError as err:
    print(err)  # will print something like "option -a not recognized"
    sys.exit(2)
    pass
print("opts:", opts)
print("args:", args)

for opt, arg in opts:
    if opt in ("-h", "--help"):
        print('./run_DBDS.py "cmd" or ./run_DBDS.py -r <reproduceFile> or ./run_DBDS.py -n <varNumConsidered> "cmd" or ./run_DBDS.py -m <memPairConsidered> or ./run_DBDS.py -d <bugDepth> "cmd"')
        sys.exit()
    elif opt in ("-l", "--enable-memoryleak"):
        enableMemoryLeak = 1
        print("Enable Memory Leak check")
    elif opt in ("-f", "--runs"):
        if arg.isdigit():
            if int(arg) > 0:
                runs_limit = int(arg)
                print("runs_limit:", runs_limit)
            else:
                print("Invaild runs_limit")
                sys.exit()
        else:
            print("runs_limit is not a digit.")
            sys.exit()
    elif opt in ("-y", "--skip-enter"):
        skipEnter = 1
    elif opt in ("-o", "--overhead-testing"):
        recordERR = 0
        check_STDOUT = 1
        check_STDERR = 0
    elif opt in ("-r", "--reproduceFile"):
        reproduceFile = arg
        TaskReproduce = 1
        print("reproduceFile:", reproduceFile)
    elif opt in ("-m", "--memPairConsidered"):
        if arg.isdigit():
            if int(arg) > 8:
                print("memPairConsidered is too large.")
                sys.exit()
            else:
                memPairConsidered = int(arg)
                print("memPairConsidered:", memPairConsidered)
        else:
            print("memPairConsidered is not a digit.")
            sys.exit()
    elif opt in ("-n", "--varNumConsidered"):
        if varNumConsidered != 0:
            print("'-n' and '-m' cannot be used at the same time.")
            sys.exit()
        if arg.isdigit():
            if int(arg) > 8:
                print("varNumConsidered is too large.")
                sys.exit()
            else:
                varNumConsidered = int(arg)
                print("varNumConsidered:", varNumConsidered)
        else:
            print("varNumConsidered is not a digit.")
            sys.exit()
    elif opt in ("-d", "--bugDepth"):
        if arg.isdigit():
                bugDepth = int(arg)
                print("bugDepth:", bugDepth)
                period_limit = bugDepth + 1
        else:
            print("bugDepth is not a digit.")
            sys.exit()
    elif opt in ("-t", "--timeout"):
        if arg.isdigit():
                subprocessTimeout = int(arg)
                print("subprocessTimeout:", subprocessTimeout)
        else:
            print("subprocessTimeout is not a digit.")
            sys.exit()

# load mempair.xxx.npz
if varNumConsidered != 0 or memPairConsidered != 0:
    exename = args[0].replace("./", "")
    if 'LD_LIBRARY_PATH=' in exename and '' in exename:
        exename = exename[exename.rfind('/')+1:]
    if '/' in exename:
        SlashIndex = exename.rfind('/')
        memInfoFile = exename[0:SlashIndex+1] + "mempair." + exename[SlashIndex+1:] + ".npz"
    else:
        memInfoFile = "mempair." + exename + ".npz"
    if os.path.exists(memInfoFile):
        LoadMemInfoFile = 1
        print("memInfoFile:", memInfoFile)
    else:
        print("cannot find memInfoFile: " + memInfoFile + ".")
        sys.exit()
print()

# Processing parameters/argv
DryRun_Command = ['sudo','Dry_Run=1','DBDS_Run=0','NO_Trace=1','ASAN_OPTIONS=abort_on_error=1:detect_leaks=0'] # the command for running program (adding sudo) # skip data race in dry run 'TSAN_OPTIONS=report_bugs=0'
DBDS_Command = ['sudo','Dry_Run=0','DBDS_Run=1', 'ASAN_OPTIONS=abort_on_error=1:detect_leaks=0']# the command for running program (adding sudo)

if enableMemoryLeak == 1:
    DBDS_Command[3] = DBDS_Command[3].replace("detect_leaks=0","detect_leaks=1")

if (len(args) > 0):
    for i in range(0,len(args)):
        DryRun_Command.append(args[i])
        DBDS_Command.append(args[i])
        
DBDS_Command_Str = ' '.join(DBDS_Command)
DryRun_Command_Str = ' '.join(DryRun_Command)

# load npz data for memory Info
pureSoList = []
memGroupList = []
memPairList = []

if LoadMemInfoFile == 1:
    if not os.path.exists(memInfoFile):
        print("memInfoFile " + memInfoFile + " not exists.")
        sys.exit()
    NPZ = np.load(memInfoFile,allow_pickle=True)
    pureSoList = NPZ["arr_0"].tolist()
    memGroupList = NPZ["arr_1"].tolist()
    memPairList =  NPZ["arr_2"].tolist()

    print("\033[34mpureSoList: \033[0m")
    for each in pureSoList:
        print(each)
    print()

    print("\033[34mmemGroupList: \033[0m")
    for each in memGroupList:
        print(each)
    print()

    #print("\033[34mmemPairList: \033[0m")
    #for each in memPairList:
        #print(each)
    #print()

# ================= Finish Parameter processing phase ========================

# perform dry run
print("\n\033[4;36mPerform Dry Run!\033[0m")
process = subprocess.Popen(DryRun_Command, close_fds=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
dryrunstdout, dryrunerrdata = process.communicate(timeout=subprocessTimeout)
if(process.returncode!=0 and process.returncode!=1 and process.returncode!=6 and process.returncode!=-11):
    sys.exit()
if(process.returncode==1):
    exceptionFlag=0
    try:
        dryrun_context_strings = dryrunerrdata.decode("utf-8")
        if ": command not found" in dryrun_context_strings:
            print(dryrun_context_strings)
            exceptionFlag=1
    except:
        print("An exception occurred in dry run")
        pass
    if exceptionFlag == 1:
        sys.exit()

# set up shared memory (put it here is important)
ADDR = setup_share_memroy()
memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(0)), sizeof(c_uint))

# Get the number of threads and the number of key points per thread

P = c_ulonglong(0)
A = c_uint(0)
B = c_uint(0)
T = c_uint(0)
kpNumArray = (c_uint*SHARE_THREAD_NUM)(0)
kpYieldArray = (c_uint*SHARE_ARRAY_SIZE)(0)
kpLocArray = (c_uint*SHARE_ARRAY_SIZE)(0)
kpOrderArray = (c_uint*SHARE_ARRAY_SIZE)(0)

get_info_from_share_memory(P,A,B,T,kpNumArray,None,None,None)

Period = P.value
N = A.value
if N > SHARE_THREAD_NUM:
    print("Too many threads...")
    sys.exit(1)
M = B.value
if M > SHARE_ARRAY_SIZE:
    print("Too many scheduling points")
    sys.exit(1)
TupleFirst = T.value
# update kpMaxNumArray
for i in range(0,N):
    if kpNumArray[i] > kpMaxNumArray[i]:
        kpMaxNumArray[i] = kpNumArray[i]

# print_Info_from_shm(N, M, None, kpNumArray, None, None, None, [], None, True) # Only use for debug

# reproduce a certain interleavings if provided "-r"
if TaskReproduce == 1:
    try:
        with open (reproduceFile,"rb") as f:
            first_line_b = f.readline()  # take first line
            first_line = str(first_line_b, encoding = "utf8")
            pattern_list = literal_eval(first_line) # 通过 literal_eval 这个函数，将str类型的列表转换成类型为list的真正的列表类型

            threadNum = len(pattern_list)
            KPNum = len(pattern_list[0])
            # print()
            # print("+ period:", Period)
            # print("+ threadNum:", threadNum, " threadNum:", N)
            # print("+ KPNum:", KPNum, " KPNum:", M)
            
            # write the config to shared memory
            memmove(ADDR, byref(c_ulonglong(int(Period*1.5))), sizeof(c_ulonglong)) # amplify period limit
            memmove(ADDR + sizeof(c_ulonglong), byref(c_uint(threadNum)), sizeof(c_uint))
            memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint), byref(c_uint(KPNum)), sizeof(c_uint))
            memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(0)), sizeof(c_uint))   
            memmove_pattern_list(pattern_list)
      
        print("\n\033[4;36mPerform Reproduction!\033[0m")
        process = subprocess.Popen(DBDS_Command, close_fds=True)
        process.communicate()
        sys.exit()
                    
    except IOError:
        print("Failed to open the target reproduce file.")
        sys.exit()


# Dynamically change period_limit 
if N > 2:
    period_limit = period_limit + N - 2

# report warning if there are too many Key Points or Threads
if N > SHARE_THREAD_NUM or M*N > SHARE_ARRAY_SIZE:
    print("ERROR: Too many Key Points or Threads.")
    print("N = ", N, "M = ", M)
    sys.exit(1)

# create output folder for saveing the error interleavings
folder_name = ""
if '/' in args[0]:
    folder_name = "out_" + args[0].split('/')[-1]
else:
    folder_name = "out_" + args[0]

fi = 1
while (os.path.exists(folder_name + "_" + str(fi))):
    fi = fi + 1

folder_name = folder_name + "_" + str(fi)
os.makedirs(folder_name+"/"+"Errors")
os.makedirs(folder_name+"/"+"DiffResult")
os.makedirs(folder_name+"/"+"Timeouts")

# run the interleaving for yield pattern [0, 0, 0, 0, ..., 0, 1, 1, 1, ..., 1]
# ZeroPattern = [[0]*M]*N # worng
ZeroPattern = [[row for col in range(M)] for row in range(N)]
for each in ZeroPattern:
    for i in range(1,len(each)):
        each[i] = 0
memmove_pattern_list(ZeroPattern)

returnNormal = 0
while returnNormal < 3:
    
    if returnNormal == 0:
        print("\n\033[4;36mPerform DBDS Run with default system scheduling!\033[0m")
    else:
        print("\n\033[4;36mPerform DBDS Run again due to increasing number of Key Points!\033[0m")

    memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(0)), sizeof(c_uint))
    process = subprocess.Popen(DBDS_Command, close_fds=True)
    process.communicate()
    
    # get more info from share memory
    get_info_from_share_memory(P,A,B,T,kpNumArray,kpYieldArray,kpLocArray,kpOrderArray)

    # update kpMaxNumArray
    for i in range(0,N):
        if returnNormal == 0 and kpNumArray[i] >=1:
            kpMaxNumArray[i] = kpNumArray[i]
        else:
            if kpNumArray[i] > kpMaxNumArray[i]:
                kpMaxNumArray[i] = kpNumArray[i]

    if (process.returncode == 0 or process.returncode == 1 or process.returncode == 6 or process.returncode == -11): #and A.value != 1 and A.value != 0:
        if A.value > N or B.value > M or check_and_update_kpNumMaxArray(kpNumArray):
            if A.value > N:
                N = A.value
            if B.value > M:
                M = B.value
            check_and_update_kpNumMaxArray(kpNumArray) # This function would not be executed in the while condiction
            memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(0)), sizeof(c_uint))

            returnNormal = returnNormal + 1
        else:
            if N != 0 and N != 1:
                returnNormal = 4
            else:
                returnNormal = returnNormal + 1
    else:
        returnNormal = returnNormal + 1
    
    if returnNormal == 3:
        print("There seems to be some errors when executing the default schedule.")
        print("Please execute it again.")
        sys.exit(1)
    elif returnNormal == 4:
        break

# save the parentArray
for i in range(0,A.value):
    parentArray[i] = kpNumArray[i]

# print info into the screen
print("\n--------------------------------------")
print("Runtime:", Period)
coverage_hashID = calculate_coverage_hashID(kpLocArray, M*N, kpNumArray, N, SHARE_ARRAY_SIZE)
print_Info_from_shm(N, M, TupleFirst, kpNumArray, kpYieldArray, kpLocArray, kpOrderArray, [], coverage_hashID, True)
print("--------------------------------------")
print("Enter 'debug' to view the debug information")
if skipEnter == 0:
    input_from_user = input("Press Enter to continue...\n")
    if input_from_user == "debug" or input_from_user == "DEBUG" or input_from_user == "Debug":
        print("--------------------------------------")
        print_Info_from_shm(N, M, TupleFirst, kpNumArray, kpYieldArray, kpLocArray, kpOrderArray, [], default_coverage_hashID, zero_in_KP, True)
        input("Press Enter to continue...")
else:
    pass


DBDS_stage = 1 # record the stage in our testing, init 1
waited_to_explore = OrderedDict() # save those interleaving that more key points are covered
prefix = []

VarModeFlag = -1 # if VarModeFlag == 0, the next if statement will return true
directInterList = []  # [inter,useful_kp_num_list, useful_kp_index_list] use for false branch
printSecondFlag = 0 # used to display the second reading
if LoadMemInfoFile == 0 or varNumConsidered > len(memGroupList) or memPairConsidered > len(memPairList) or len(memGroupList) < 3 or len(memPairList) < 3 or M < 8:
    print("Consider all variables")
    VarModeFlag = 0

    # calculate the interleaving
    MList = []
    for i in range(0,N):
        MList.append(kpMaxNumArray[i])
    inter = interleaving.interleaving_init(N, MList)
    #inter = interleaving.interleaving_init(N, [M])

elif varNumConsidered !=0:
    print("Consider " + str(varNumConsidered) + " variables")
    VarModeFlag = 1

    # get combinations from memGroup
    for eachComb in combinations([n for n in range(0, len(memGroupList))], varNumConsidered):
        
        # save each Comb into a tmpList
        tmpLocList = []
        for eachIndex in eachComb:
            for eachRWSO in memGroupList[eachIndex][1]:
                tmpLocList.append(eachRWSO)
            for eachRWSO in memGroupList[eachIndex][2]:
                tmpLocList.append(eachRWSO)
            for eachRWSO in memGroupList[eachIndex][3]:
                tmpLocList.append(eachRWSO)
        tmpLocList = sorted(set(tmpLocList), key=tmpLocList.index)

        # find Corresponding Hash Value
        tmpHashList = []
        for eachKp in tmpLocList:
            for eachSo in pureSoList:
                if eachSo[0] == eachKp:
                    tmpHashList.append(eachSo[3])

        # mark useful KP at this round
        useful_kp_num_list = [0]*N
        useful_kp_index_list = []
        for eachHashID in tmpHashList:
            for i in range(0, M*N):
                if str(kpLocArray[i]) == eachHashID:
                    useful_kp_num_list[int(i/M)] = useful_kp_num_list[int(i/M)] + 1
                    useful_kp_index_list.append(i)
        useful_kp_index_list = sorted(useful_kp_index_list)

        # if useful_kp_num_list contains lots of zero, no use
        how_many_zero = 0
        for each in useful_kp_num_list:
            if each != 0:
                how_many_zero = how_many_zero + 1
        if how_many_zero < 2:
            continue

        #print(useful_kp_num_list)
        #print(useful_kp_index_list)

        printSecondFlag = printSecondFlag + 1
        if printSecondFlag == 50:
            printSecondFlag = 0
            print("Generating permutation combinations...")

        # calculate the interleaving
        inter = interleaving.interleaving_init(N, useful_kp_num_list)

        # save these inter into directInterList
        directInterList.append([inter, useful_kp_index_list, tmpLocList])

        # get first element
        inter = directInterList[0][0]
else:
    VarModeFlag = 2
    print("to be continue...")

print("\n\033[4;36mStart Testing!\033[0m")

# only use for (VarModeFlag == 1) branch
CurdirectInter =  []
if directInterList != []:
    CurdirectInter = directInterList.pop()
    print("\033[4;36mExploration of these KP:\033[0m", CurdirectInter[2])

each_runs_limit = 0
while True:

    rounds += 1
    if not prefix == []:
        print("\033[4;36mtest", str(format(rounds,"0>4"))+" for prefix " + str(prefix) + ":\033[0m ", end="")
    else:
        print("\033[4;36mtest", str(format(rounds,"0>4"))+":\033[0m ", end="")
    
    if runs_limit != 0 and rounds > runs_limit:
        break
    
    prefixPrint = get_prefix(inter)
    if VarModeFlag == 0:
        # for each interleaving, get the yield pattern
        pattern = interleaving.yield_pattern_gen(N, inter, False)
        # print pattern into screen
        print(inter)  #print(pattern) #print(get_period(inter))
        # align pattern list (filled with zero)
        filled_with_zero(pattern, M)
    else:
        # for each interleaving, get the yield pattern
        if CurdirectInter != []:
            inter = CurdirectInter[0]
            simplicityPattern = interleaving.yield_pattern_gen(N, inter, False)

            pattern = [[0] * M for i in range(N)]
            patternList = []
            for each in simplicityPattern:
                patternList = patternList + each
            
            # Fill the simplified pattern to the complete pattern
            useful_kp_index_list = CurdirectInter[1]
            for i in range(0, len(useful_kp_index_list)):
                pattern[int(useful_kp_index_list[i]/M)][useful_kp_index_list[i] - int(useful_kp_index_list[i]/M)*M] = patternList[i]
            # print pattern into screen
            print(inter) # print(simplicityPattern)
        else: # same with VarModeFlag == 0
            # for each interleaving, get the yield pattern
            pattern = interleaving.yield_pattern_gen(N, inter, False)
            # print pattern into screen
            print(inter) # print(pattern)
            # align pattern list (filled with zero)
            filled_with_zero(pattern, M)

    # write the config to shared memory
    # memmove(ADDR, byref(c_ulonglong(Period)), sizeof(c_ulonglong))
    memmove(ADDR + sizeof(c_ulonglong), byref(c_uint(N)), sizeof(c_uint))
    memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint), byref(c_uint(M)), sizeof(c_uint)) #必需用最大的M
    memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(0)), sizeof(c_uint))

    memmove_pattern_list(pattern)
    
    # create subprocess according to the value of check_STDOUT and check_STDERR
    process = create_DBDS_subprocess(check_STDOUT, check_STDERR)

    try:
        # join subprocess
        if recordERR:
            stdoutdata, stderrdata = process.communicate(timeout=subprocessTimeout)
        else:
            process.communicate(timeout=subprocessTimeout)
    
        # get info from share memory
        get_info_from_share_memory(None,A,B,T,kpNumArray,kpYieldArray,kpLocArray,kpOrderArray)

        # update NMKPNUMA and rerun
        check_and_update_kpNumMaxArray(kpNumArray)
        
        # The array for storing KP is too small. Reset the array size and perform the test again
        while A.value > N or B.value > M:

            if A.value > N:
                N = A.value
            if B.value > M:
                M = B.value
            
            print("\033[4;36mtest", str(format(rounds,"0>4"))+" (retest) \033[0m ")
            memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(0)), sizeof(c_uint))
            process = create_DBDS_subprocess(check_STDOUT, check_STDERR)
            if recordERR:
                stdoutdata, stderrdata = process.communicate(timeout=subprocessTimeout)
            else:
                process.communicate(timeout=subprocessTimeout)
            get_info_from_share_memory(None,A,B,T,kpNumArray,kpYieldArray,kpLocArray,kpOrderArray)

        parentArrayCopy = parentArray.copy()
        coverFlag = 0
        if new_max_kpNumArray(kpNumArray, parentArray):
            coverFlag = 1
        parentArray = parentArrayCopy # restore parentArray
        
        # if new coverage, we save the prefix of interleaving
        coverage_hashID = calculate_coverage_hashID(kpLocArray, M*N, kpNumArray, N, SHARE_ARRAY_SIZE)
        if coverFlag == 1 :
            kpNumList = []
            for i in range(0,A.value):
                kpNumList.append(kpNumArray[i])
            # This is a replacement. A sequence with the same hash value that appears later replaces an existing sequence. So if there's anything new than your parents, replace old ones with the same hash value.
            add_to_explore_dict(waited_to_explore, coverage_hashID, inter.copy(), pattern.copy(), A.value, B.value, kpNumList.copy(), [get_prefix(inter).copy()])

        # save the error message
        if recordERR:
            #print("[DEBUG] process.returncode = ", process.returncode)
            record_error_message(process, folder_name, stdoutdata, stderrdata, pattern, rounds)

        # [debug] print info from share memory
        if DebugInfo:
            print_Info_from_shm(A.value, B.value, T.value, kpNumArray, kpYieldArray, kpLocArray, kpOrderArray, prefixPrint, coverage_hashID, False)
    
    except subprocess.TimeoutExpired:
        # process.kill()
        # process.terminate()
        subprocess.check_call(["sudo", "kill", str(process.pid)])
        #os.waitpid(process.pid, 0)
        if recordERR:
            record_timeout_message(folder_name, pattern)
    
    except Exception as e:
        print("\033[34m\tUnknown Exception" + "\033[0m")
        print(e)

    # if cannot find next interleaving
    if DBDS_stage == 1:
        find_legal_inter = 0
        while interleaving.interleaving_next(inter):
            if period_limit == 0 or compare_period(inter, period_limit): # Limit the number of period
                find_legal_inter = 1
                break
            else:
                continue
        if find_legal_inter == 0:
            if VarModeFlag == 0:
                DBDS_stage = 2
            else:
                if directInterList != []:
                    CurdirectInter = directInterList.pop()
                    print("\033[4;36mExploration of these KP:\033[0m", CurdirectInter[2])
                else:
                    CurdirectInter = []
                    DBDS_stage = 2

    if DBDS_stage == 2:

        while_flag = 0
        while waited_to_explore:
            popItem = waited_to_explore.popitem(last=False)
            tempL = popItem[1]
            prefix = get_prefix(tempL[0]) # keep only the prefix of parent interleaving
            #period_limit = period_save + get_period(prefix) - 1 # Dynamic change period, or use get_period(prefix) + 3
            if prefix == [] or get_period(prefix) == period_limit - 1: # the prefix is already beyond the limit of the number of period
                continue
            tmpMList = []
            parentArray = [0]*SHARE_THREAD_NUM
            for i in range(0, tempL[2]): # range(0, A.value)
                tmpMList.append(tempL[4][i])
                parentArray[i] = tempL[4][i]
            tmpiter = interleaving_iter(tempL[2], tmpMList, tempL[0]) # interleaving_iter(N, [M], inter)
            inter = next(tmpiter)
            DBDS_stage = 1
            
            while_flag = 1
            break

        if while_flag == 0:
            break

print("\033[4;36mEnd Testing!\n\033[0m")

print("\033[1;35m")
print('Total Error Interleavings:',total_errors_interleavings[0])
print('Total Timeouts Interleavings:',total_timeouts_interleavings[0])
print(len(statusL), 'status found:')
print("\t",statusL)
print(len(rlts), 'results found:')
for each in rlts:
    print("\t",each)
print('-' * 50)
print('\tLast New Find\t\tTotal')
print('Round\t{0}\t\t\t{1}'.format(lastRound, rounds))
print('Time\t' + formateTime(lastTime - startTime), end = "")
print('\t\t' + formateTime(time.time() - startTime))
print("\033[0m")
exit()
