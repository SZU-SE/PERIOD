# Static Analysis

This page shows how to perform our static analysis to find key points that may cause potential data race/concurrency bugs.

-----

## Quick Start

We use the file [transfer.c](../../test/transfer/transfer.c) as our running example.

Before performing static analysis for `transfer.c`, we need to compile the program and obtain its bitcode file:

```bash
$ export PATH=${ROOT_DIR}/clang+llvm/bin:$PATH
$ export LD_LIBRARY_PATH=${ROOT_DIR}/clang+llvm/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}
$ cd $ROOT_DIR/test/transfer
$ clang -g -O -emit-llvm -c ./transfer.c -o transfer.bc
```

Then use the script `obsoleteStaticAnalysis.sh` static to perform the static analysis:

```bash
$ $ROOT_DIR/tool/staticAnalysis/obsoleteStaticAnalysis.sh transfer
```

Then you can see the result in the file `mempair.transfer`.

```
transfer.c:11:0 transfer.c:12:0 R W
transfer.c:12:0 transfer.c:12:0 W W
transfer.c:12:0 transfer.c:27:0 W R
transfer.c:13:0 transfer.c:13:0 W R
transfer.c:13:0 transfer.c:27:0 W R
```

-----

## Detail Workflow

This Section is too detailed. For ordinary users, using using the top-level  the script `obsoleteStaticAnalysis.sh` is enough. 

The script `obsoleteStaticAnalysis.sh` consists of several parts.

### Use SVF to Generate a Trimmed Memory SSA.

SVF is a static tool that enables scalable and precise interprocedural dependence analysis for C and C++ programs. SVF allows value-flow construction and pointer analysis to be performed iteratively, thereby providing increasingly improved precision for both. SVF accepts the points-to information generated by any pointer analysis (e.g., Andersenâ€™s analysis) and constructs an interprocedural [memory SSA](https://llvm.org/docs/MemorySSA.html) form so that the def-use chains of both top-level and address-taken variables are captured. SVF is implemented on top of an industry-strength compiler [LLVM](http://llvm.org/).

We use a modified version of SVF to dump SVFG and Trimmed Memory SSA, by using following command:

```bash
$ export PATH=$ROOT_DIR/tool/SVF/Release-build/bin/:$PATH
$ $ROOT_DIR/tool/staticAnalysis/analysis.py ./transfer.bc > ./mssa.transfer
```

We can get a trimmed memory SSA for function racy_transfer, it looks like the following outputs:

```sh
==========FUNCTION: racy_transfer==========

LDMU(MR_4V_1)   pts{9 }
        [[./transfer.c:11:14]]({i32})
4V_3 = STCHI(MR_4V_1)   pts{9 }
        [[./transfer.c:12:22]]({i32})

LDMU(MR_2V_1)   pts{6 }
        [[./transfer.c:13:20]]({i32})
2V_3 = STCHI(MR_2V_1)   pts{6 }
        [[./transfer.c:13:20]]({i32})

==========FUNCTION: main==========

LDMU(MR_2V_3)   pts{6 }
        [[./transfer.c:27:23]]({i32})

LDMU(MR_4V_3)   pts{9 }
        [[./transfer.c:27:35]]({i32})
```

### From Memory SSA to Mempair

We then extract the aliased pair from memory SSA. We provide `get_aliased_pair.py` to obtain aliased_pair.

```bash
$ $ROOT_DIR/tool/staticAnalysis/get_aliased_pair.py ./mssa.transfer > ./mempair_all.transfer
```

We get the aliased pairs, as shown in the following. For example, `transfer.c:11:0 transfer.c:12:0 R W` means that there is a memory read for variable *x* at `transfer.c:11`, and there is also a memory write for variable *x* at `transfer.c:12`

```sh
(9, 'i32') [('transfer.c:12:0', 'transfer.c:12:0'), ('transfer.c:12:0', 'transfer.c:11:0'), ('transfer.c:12:0', 'transfer.c:27:0')] [('W', 'W'), ('W', 'R'), ('W', 'R')]
(6, 'i32') [('transfer.c:13:0', 'transfer.c:13:0'), ('transfer.c:13:0', 'transfer.c:13:0'), ('transfer.c:13:0', 'transfer.c:27:0')] [('W', 'W'), ('W', 'R'), ('W', 'R')]
```

### Get Prune Mempair

The script `prune.py` is use to get prune mempair.

```bash
$ $ROOT_DIR/tool/staticAnalysis/prune.py ./mempair_all.transfer > ./mempair.transfer
```

The prune mempair have no redundant or duplicate pairs.

```sh
transfer.c:11:0 transfer.c:12:0 R W
transfer.c:12:0 transfer.c:12:0 W W
transfer.c:12:0 transfer.c:27:0 W R
transfer.c:13:0 transfer.c:13:0 W R
transfer.c:13:0 transfer.c:27:0 W R
```

### Change Prune Mempair to single Line for Instrumentation

When performing instrumentation, we only focus on the line number.

```bash
$ $ROOT_DIR/tool/staticAnalysis/ExtractLineStdout.py -f ./mempair.transfer > ./ConConfig.transfer
```

The results are looks like the following output:

```sh
transfer.c:27
transfer.c:11
transfer.c:12
transfer.c:13
```

### Analyze Sensitive Memory Operations

We use a LLVM PASS to analyze sensitive memory operations, such as free(x), x=NULL, etc.

we take [uaf.c](../../test/UAF/uaf.c) as an example.

```bash
$ export PATH=${ROOT_DIR}/clang+llvm/bin:$PATH
$ export LD_LIBRARY_PATH=${ROOT_DIR}/clang+llvm/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}
$ cd $ROOT_DIR/test/UAF
$ clang -g -O -emit-llvm -c ./uaf.c -o uaf.bc
$ export PATH=$ROOT_DIR/tool/SVF/Release-build/bin/:$PATH
$ $ROOT_DIR/tool/staticAnalysis/analysis.py ./uaf.bc > ./mssa.uaf
$ $ROOT_DIR/tool/staticAnalysis/get_aliased_pair.py ./mssa.uaf > ./mempair_all.uaf
$ $ROOT_DIR/tool/staticAnalysis/prune.py ./mempair_all.uaf > ./mempair.uaf
$ $ROOT_DIR/tool/staticAnalysis/ExtractLineStdout.py -f ./mempair.uaf > ./ConConfig.uaf
$ export Con_PATH=${ROOT_DIR}/test/UAF/ConConfig.uaf
$ opt -load $ROOT_DIR/tool/staticAnalysis/LLVM-PASS/SensitiveOperationsPass/libSensitiveOperationsPass.so -so ./uaf.bc -o /dev/null > so.uaf
```

We can get the sensitive memory operations, as shown in the following:

```sh
uaf.c:15 R/W t1
uaf.c:15 R/W t1
uaf.c:17 R/W t1
uaf.c:17 R/W t1
uaf.c:17 R/W t1
uaf.c:20 R/W t1
uaf.c:20 free t1
uaf.c:21 nullptr t1
uaf.c:30 R/W t2
uaf.c:30 R/W t2
uaf.c:30 R/W t2
uaf.c:34 R/W main
uaf.c:35 malloc main
uaf.c:35 R/W main
uaf.c:36 malloc main
uaf.c:36 R/W main
uaf.c:45 R/W main
uaf.c:45 R/W main
```

Then, use to `updateMempairSo.py` to update mempair.

```bash
$ $ROOT_DIR/tool/staticAnalysis/updateMempairSo.py -i ./so.uaf -m mempair.uaf > mempairso.uaf
```

The mempair could be:

```sh
uaf.c:15 uaf.c:15 W W
uaf.c:15 uaf.c:34 W W
uaf.c:15 uaf.c:48 W R
uaf.c:17 uaf.c:17 W W
uaf.c:17 uaf.c:21 R nullptr
uaf.c:17 uaf.c:30 W R
uaf.c:17 uaf.c:35 R malloc
uaf.c:17 uaf.c:36 W malloc
uaf.c:20 uaf.c:21 free nullptr
uaf.c:20 uaf.c:35 free malloc
uaf.c:21 uaf.c:21 nullptr nullptr
uaf.c:21 uaf.c:35 nullptr malloc
uaf.c:30 uaf.c:30 W W
uaf.c:30 uaf.c:36 R malloc
uaf.c:34 uaf.c:34 W W
uaf.c:34 uaf.c:48 W R
uaf.c:35 uaf.c:35 malloc malloc
uaf.c:36 uaf.c:36 malloc malloc
```
