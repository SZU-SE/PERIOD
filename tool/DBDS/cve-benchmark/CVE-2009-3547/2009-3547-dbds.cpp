#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <iostream>
#include <stdlib.h>
#include <time.h>

#include <sys/shm.h>
#include <sys/types.h>
#include "../../sched.h"

// #define TEST_TIME

using namespace std;

// F: code blocks annotated with "// F:" are introduced to guide fuzzing
typedef struct Sched_Info {
    int N;          // number of threads concerned
    int M;          // number of kep points per thread
    int kp[10000];  // how many times should a thread yield before a kp
} sched_info;

// F: the information used to guide the scheduling
sched_info * si;


struct pipe_inode_info
{
    unsigned int writers;
    unsigned int readers;

    pipe_inode_info()
    {
        writers = 0;
        readers = 0;
    }
};

struct INODE
{
    pthread_mutex_t i_mutex;
    struct pipe_inode_info *i_pipe;

    INODE()
    {
        pthread_mutex_init(&i_mutex, NULL);
        i_pipe = new pipe_inode_info();
    }
};


struct INODE* inode = new INODE();

static void* pipe_write_open(void* arg)
{

    while(get_tid_to_run() == 0);		// F: wait until its his turn
    int sched_tid = get_tid_to_run();	// F: acquire the tid for sechduling
    set_tid_to_run(0);					// F: notify main thread to run

    // F: set the thread to use deadline scheduling
    set_sched_dl(1000 * 1000, 1000 * 1000 * 10, 1000 * 1000 * 10);
    int idx_kp = (sched_tid - 1) * (si -> M);
    printf("t_%d: started\n", sched_tid);

    // F: give up several circles' time
    while(1) {
        printf("t_%d: %d times to yield at KP %d.%d\n", sched_tid,
               si -> kp[idx_kp], sched_tid,
               idx_kp - (sched_tid - 1) * (si -> M));
        if(si -> kp[idx_kp] <= 0) break;
        sched_yield();
        si -> kp[idx_kp]--;
    }
    idx_kp++;

    pthread_mutex_lock(&inode->i_mutex);

    inode->i_pipe->readers++;
    cout << "threadA: " << std::hex << inode->i_pipe << endl;

    pthread_mutex_unlock(&inode->i_mutex);

    return NULL;
}

static void* involve(void* arg)
{
    while(get_tid_to_run() == 0);		// F: wait until its his turn
    int sched_tid = get_tid_to_run();	// F: acquire the tid for sechduling
    set_tid_to_run(0);					// F: notify main thread to run

    // F: set the thread to use deadline scheduling
    set_sched_dl(1000 * 1000, 1000 * 1000 * 10, 1000 * 1000 * 10);
    int idx_kp = (sched_tid - 1) * (si -> M);
    printf("t_%d: started\n", sched_tid);

    // F: give up several circles' time
    while(1) {
        printf("t_%d: %d times to yield at KP %d.%d\n", sched_tid,
               si -> kp[idx_kp], sched_tid,
               idx_kp - (sched_tid - 1) * (si -> M));
        if(si -> kp[idx_kp] <= 0) break;
        sched_yield();
        si -> kp[idx_kp]--;
    }
    idx_kp++;

    pthread_mutex_lock(&inode->i_mutex);
    inode->i_pipe = NULL;
    pthread_mutex_unlock(&inode->i_mutex);
    cout << "threadB: " << std::hex << inode->i_pipe << endl;

    return NULL;
}

int main()
{
#ifdef TEST_TIME
    static double run_time_begin;
    static double run_time_end;
    static double run_time_total;
    run_time_begin = clock();
#endif

    pthread_t t1, t2;

    // F: set up the yield patten using shared memory
	int shmid;
    key_t key = 1111;
    // Setup shared memory
    if ((shmid = shmget(key, sizeof(sched_info), IPC_CREAT | 0666)) < 0) {
        printf("Error getting shared memory id. 1\n");
        exit(1);
    }
	// Attached shared memory
    if ((sched_info *) -1 == (si = (sched_info *) shmat(shmid, NULL, 0))) {
        printf("Error attaching shared memory id. 2\n");
        exit(1);
    }

    set_tid_to_run(0);	// F: allow the main thread to run
	int c_tid = 0;		// F: child tid, initially 0

    while(get_tid_to_run() != 0);	// F: wait until its his turn
	c_tid++;						// F: get the next child tid
	set_tid_to_run(c_tid);			// F: notify thread 1 to get ready

    pthread_create(&t1, NULL, pipe_write_open, NULL);

    while(get_tid_to_run() != 0);	// F: wait until its his turn
	c_tid++;						// F: get the next child tid
	set_tid_to_run(c_tid);			// F: notify thread 1 to get ready

    pthread_create(&t2, NULL, involve, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("\nprogram-successful-exit\n");

#ifdef TEST_TIME
    run_time_end = clock();
    run_time_total = run_time_end - run_time_begin;
    printf("test-the-total-time: %.3lf\n", (double)(run_time_total/CLOCKS_PER_SEC)*1000);
#endif

    return 0;
}
