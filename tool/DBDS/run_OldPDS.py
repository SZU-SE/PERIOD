#!/usr/bin/env python3

# This is the structrue of Share Memory class
SHARE_THREAD_NUM = 100
SHARE_ARRAY_SIZE = 1990
# typedef struct Sched_Info {
#	uint64_t time;								// the execution time of the program (nsec)
#	unsigned int N;								// number of threads concerned
#	unsigned int M;								// number of kep points per thread
#	unsigned int TestedPeriod;					// It took several period in testing engine
#	unsigned int kpNumArray[SHARE_THREAD_NUM];	// the specific kpNum of each My_tid Thread, only consider almost 10 thread
#	unsigned int kp[SHARE_ARRAY_SIZE];			// how many times should a thread yield before a kp
#	unsigned int kpLoc[SHARE_ARRAY_SIZE];		// the hash ID of Key Point
#	unsigned int kpOrder[SHARE_ARRAY_SIZE];		// recored the order of key points
# } sched_info;

# =================================================================================

import sys, subprocess, time, interleaving, os, getopt, copy, signal
from external_def import get_ASAN_error_type, formateTime, filled_with_zero, calculate_coverage_hashID, add_to_explore_dict, print_Info_from_shm, getMaxNuminPattern, is_redundant_with_prefix, zero_num
from collections import OrderedDict
from datetime import datetime
from ast import literal_eval
from ctypes import *
from interleaving import *
from bp_sched import *
from sbp_sched import *
from sbp_sched_mixed_end import *
from ipc import *
from itertools import combinations, permutations
import numpy as np

DebugInfo = False                   # Set “True”, if you want to get debug information

FILE_SAVED_MAXNUM =  10000          # The max number of error interleavings we can saved
subprocessTimeout = 5
rlts = []                           # the set of unique results generated by the c program
statusL = []                        # the set of unique status generated by the c program
startTime = time.time()
lastTime  = time.time()             # the time when a new result is found
rounds = lastRound = 0
output_num = [0]                    # the number of different outputs
total_errors_interleavings = [0]    # the number of errors
total_timeouts_interleavings = [0]  # the number of timeouts
recordERR = 1
check_STDOUT = 1                    # Set 2 if you want to record diff result
check_STDERR = 1                    # Set 1 if you want to record err result
kpMaxNumArray = [0]*SHARE_THREAD_NUM
parentArray = [0]*SHARE_THREAD_NUM
parentArrayCopy = [0]*SHARE_THREAD_NUM

def setup_share_memroy():
    IPC_KEY, MAP_SIZE, IPC_CREAT, IPC_EXCL = 1111, sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM+3*SHARE_ARRAY_SIZE), 512, 1024
    shmget = cdll.LoadLibrary("libc.so.6").shmget
    shmat = cdll.LoadLibrary("libc.so.6").shmat
    shmat.restype = c_void_p
    shm_id = shmget(IPC_KEY, MAP_SIZE, IPC_CREAT | IPC_CREAT | 0o666)
    ADDR = shmat(shm_id, 0, 0)
    return ADDR

def get_info_from_share_memory(P=None, A=None, B=None, T=None, kpNumArray=None, kpYieldArray=None, kpLocArray=None, kpOrderArray=None):
    if P != None:
        memmove(byref(P), ADDR, sizeof(c_ulonglong))
    if A != None:
        memmove(byref(A), ADDR + sizeof(c_ulonglong), sizeof(c_uint))
    if B != None:
        memmove(byref(B), ADDR + sizeof(c_ulonglong) + sizeof(c_uint), sizeof(c_uint))
    if T != None:
        memmove(byref(T), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, sizeof(c_uint))
    if kpNumArray != None:
        memmove(byref(kpNumArray), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*3, sizeof(c_uint)*SHARE_THREAD_NUM)
    if kpYieldArray != None:
        memmove(byref(kpYieldArray), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM), sizeof(c_uint)*SHARE_ARRAY_SIZE)
    if kpLocArray != None:
        memmove(byref(kpLocArray), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM+SHARE_ARRAY_SIZE), sizeof(c_uint)*SHARE_ARRAY_SIZE)
    if kpOrderArray != None:
        memmove(byref(kpOrderArray), ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM+2*SHARE_ARRAY_SIZE), sizeof(c_uint)*SHARE_ARRAY_SIZE)

def memmove_pattern_list(PatternList):
    tmp = []
    for t in PatternList:
        tmp += t
    tmparr = (c_uint * len(tmp))(*tmp)
    memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*(3+SHARE_THREAD_NUM), tmparr, sizeof(c_uint) * len(tmp))

# create subprocess according to the value of check_STDOUT and check_STDERR
def create_DBDS_subprocess(check_STDOUT, check_STDERR):
    if (check_STDOUT >= 1 and check_STDERR == 1):
        process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    elif (check_STDOUT >= 1 and check_STDERR == 0):
        process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp, stdout=subprocess.PIPE)
    elif (check_STDOUT == 0 and check_STDERR == 1):
        process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp, stderr=subprocess.PIPE)
    else:
        process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp)
    return process

# save the error message
def record_error_message(process, folder_name, stdoutdata, stderrdata, pattern, rounds):
    
    CrashType, CrashDesc = get_ASAN_error_type(stderrdata)
    
    lastFlag = 0
    if(not process.returncode in statusL): # stderr
        statusL.append(process.returncode)
        lastFlag = 1

    if(process.returncode!=0 and process.returncode!=1 and process.returncode!=6 and process.returncode!=-11): #save result
        if total_errors_interleavings[0] < FILE_SAVED_MAXNUM:
            total_errors_interleavings[0] = total_errors_interleavings[0] + 1
            lastFlag = 1
            print("\033[31m\t[Error Found]: NO." + str(total_errors_interleavings[0]) + " " + CrashType + "\033[0m")
            err_file_name = folder_name + "/" + "Errors" + "/" + str(format(total_errors_interleavings[0],"0>6")) + "_" + str(format(rounds,"0>7")) + "_" + CrashType.replace(' ', '-')
            with open (err_file_name,"wb") as errfile:
                errfile.write(bytes(str(pattern)+"\n", encoding = "utf8"))
                if check_STDERR == 1:
                    errfile.write(stderrdata)
            print("\033[31m\tThe interleavings saved in", err_file_name, "\033[0m")
    elif(check_STDOUT > 1 and not stdoutdata in rlts): # stdout
        if output_num[0] < FILE_SAVED_MAXNUM:
            output_num[0] = output_num[0] + 1
            lastFlag = 1
            rlts.append(stdoutdata)
            out_file_name = folder_name+"/"+"DiffResult"+"/"+str(format(output_num[0],"0>6"))
            with open (out_file_name,"wb") as outfile:
                outfile.write(bytes(str(pattern)+"\n", encoding = "utf8"))
                outfile.write(stdoutdata)
        
    if(lastFlag == 1): # last Round
        lastRound = rounds
        lastTime = time.time()

# save the timeout message
def record_timeout_message(folder_name, pattern):
    if total_timeouts_interleavings[0] < FILE_SAVED_MAXNUM:
        total_timeouts_interleavings[0] = total_timeouts_interleavings[0] + 1
        print("\033[33m\t[Timeout " + str(subprocessTimeout) + "]: NO." + str(total_timeouts_interleavings[0]) + "\033[0m")
        timeout_file_name = folder_name+"/"+"Timeouts"+"/"+str(format(total_timeouts_interleavings[0],"0>6"))
        with open (timeout_file_name,"wb") as timeoutfile:
            timeoutfile.write(bytes(str(pattern)+"\n", encoding = "utf8"))
            if check_STDERR == 1:
                timeoutfile.write(bytes("Timeout = " + str(subprocessTimeout), encoding = "utf8"))
        print("\033[33m\tunder interleavings saved in", timeout_file_name, "\033[0m")

def check_and_update_kpNumMaxArray(kpNumArray, zero_in_KP):
    hasNewMax = False
    for i in range(0, N + zero_in_KP):
        if kpNumArray[i] > kpMaxNumArray[i]:
            kpMaxNumArray[i] = kpNumArray[i]
            hasNewMax = True
    return hasNewMax

def new_max_kpNumArray(kpNumArray, parentArray, zero_in_KP):
    hasNewMax = False
    for i in range(0, N + zero_in_KP):
        if kpNumArray[i] > parentArray[i]:
            parentArray[i] = kpNumArray[i]
            hasNewMax = True
    return hasNewMax

def get_period(inter):
    period = 1
    com = inter[0]
    for each in inter:
        if each == com:
            continue
        else:
            com = each
            period = period + 1
    return period

def compare_period(inter, p):
    ret = True
    period = 1
    com = inter[0]
    for each in inter:

        if each == com:
            continue
        else:
            com = each
            period = period + 1
        
        if period > p:
            ret = False
            break
        
    return ret

# ================= Start Parameter processing phase ========================

# get argv and check whether the task is reproducing a certain interleaving
reproduceFile = "" # the file that saves thread interleavings that can trigger errors.
memInfoFile = "" #  the file that saves memory group Info
varNumConsidered = 0 # Number of variables considered
bugDepth = 2 # Limit the maximum number of bug depth (defaut: 2)
period_limit = bugDepth + 1 # Limit the maximum number of period (defaut: 3)
memPairConsidered = 0 # Number of mempairs considered
skipEnter = 0 # It doesn't need to press enter to advance automatically
runs_limit = 0
TaskReproduce = 0
LoadMemInfoFile = 0
enableMemoryLeak = 0
full_deep_run = 0
no_prefix_run = 0
opts = []
args = []
try:
    opts, args = getopt.getopt(sys.argv[1:], "hlyozer:m:n:d:t:f:", ["help", "enable-memoryleak", "skip-enter", "overhead-testing", "full_deep_run=", "no-prefix", "reproduceFile=", "memPairConsidered=", "varNumConsidered=", "bugDepth=", "timeout=", "runs="])
except getopt.GetoptError as err:
    print(err)  # will print something like "option -a not recognized"
    sys.exit(2)
    pass
print("opts:", opts)
print("args:", args)

for opt, arg in opts:
    if opt in ("-h", "--help"):
        print('./run_PDS.py "cmd" or ./run_PDS.py -r <reproduceFile> or ./run_PDS.py -n <varNumConsidered> "cmd" or ./run_PDS.py -m <memPairConsidered> or ./run_PDS.py -d <bugDepth> "cmd"')
        sys.exit()
    elif opt in ("-l", "--enable-memoryleak"):
        enableMemoryLeak = 1
        print("Enable Memory Leak check")
    elif opt in ("-f", "--runs"):
        if arg.isdigit():
            if int(arg) > 0:
                runs_limit = int(arg)
                print("runs_limit:", runs_limit)
            else:
                print("Invaild runs_limit")
                sys.exit()
        else:
            print("runs_limit is not a digit.")
            sys.exit()
    elif opt in ("-y", "--skip-enter"):
        skipEnter = 1
    elif opt in ("-o", "--overhead-testing"):
        recordERR = 0
        check_STDOUT = 1
        check_STDERR = 0
    elif opt in ("-z", "--full-deep-run"):
        full_deep_run = 1
    elif opt in ("-e", "--no-prefix"):
        no_prefix_run = 1
    elif opt in ("-r", "--reproduceFile"):
        reproduceFile = arg
        TaskReproduce = 1
        print("reproduceFile:", reproduceFile)
    elif opt in ("-m", "--memPairConsidered"):
        if arg.isdigit():
            if int(arg) > 8:
                print("memPairConsidered is too large.")
                sys.exit()
            else:
                memPairConsidered = int(arg)
                print("memPairConsidered:", memPairConsidered)
        else:
            print("memPairConsidered is not a digit.")
            sys.exit()
    elif opt in ("-n", "--varNumConsidered"):
        if varNumConsidered != 0:
            print("'-n' and '-m' cannot be used at the same time.")
            sys.exit()
        if arg.isdigit():
            if int(arg) > 6:
                print("varNumConsidered is too large.")
                sys.exit()
            else:
                varNumConsidered = int(arg)
                print("varNumConsidered:", varNumConsidered)
        else:
            print("varNumConsidered is not a digit.")
            sys.exit()
    elif opt in ("-d", "--bugDepth"):
        if arg.isdigit():
                bugDepth = int(arg)
                print("bugDepth:", bugDepth)
                period_limit = bugDepth + 1
        else:
            print("bugDepth is not a digit.")
            sys.exit()
    elif opt in ("-t", "--timeout"):
        if arg.isdigit():
                subprocessTimeout = int(arg)
                print("subprocessTimeout:", subprocessTimeout)
        else:
            print("subprocessTimeout is not a digit.")
            sys.exit()

# load mempair.xxx.npz
if varNumConsidered != 0 or memPairConsidered != 0:
    exename = args[0].replace("./", "")
    if 'LD_LIBRARY_PATH=' in exename and '' in exename:
        exename = exename[exename.rfind('/')+1:]
    if '/' in exename:
        SlashIndex = exename.rfind('/')
        memInfoFile = exename[0:SlashIndex+1] + "mempair." + exename[SlashIndex+1:] + ".npz"
    else:
        memInfoFile = "mempair." + exename + ".npz"
    if os.path.exists(memInfoFile):
        LoadMemInfoFile = 1
        print("memInfoFile:", memInfoFile)
    else:
        print("cannot find memInfoFile: " + memInfoFile + ".")
        sys.exit()
print()

# Processing parameters/argv
DryRun_Command = ['sudo','Dry_Run=1','DBDS_Run=0','NO_Trace=1','ASAN_OPTIONS=abort_on_error=1:detect_leaks=0', 'TSAN_OPTIONS=report_bugs=0'] # the command for running program (adding sudo) # skip data race in dry run 'TSAN_OPTIONS=report_bugs=0'
DBDS_Command = ['sudo','Dry_Run=0','DBDS_Run=1', 'ASAN_OPTIONS=abort_on_error=1:detect_leaks=0', 'TSAN_OPTIONS=report_bugs=1']# the command for running program (adding sudo)

if enableMemoryLeak == 1:
    DBDS_Command[3] = DBDS_Command[3].replace("detect_leaks=0","detect_leaks=1")

if (len(args) > 0):
    for i in range(0,len(args)):
        DryRun_Command.append(args[i])
        DBDS_Command.append(args[i])
        
DBDS_Command_Str = ' '.join(DBDS_Command)
DryRun_Command_Str = ' '.join(DryRun_Command)

# load npz data for memory Info
pureSoList = []
memGroupList = []
memPairList = []

if LoadMemInfoFile == 1:
    if not os.path.exists(memInfoFile):
        print("memInfoFile " + memInfoFile + " not exists.")
        sys.exit()
    NPZ = np.load(memInfoFile,allow_pickle=True)
    pureSoList = NPZ["arr_0"].tolist()
    memGroupList = NPZ["arr_1"].tolist()
    memPairList =  NPZ["arr_2"].tolist()

    print("\033[34mpureSoList: \033[0m")
    for each in pureSoList:
        print(each)
    print()

    print("\033[34mmemGroupList: \033[0m")
    for each in memGroupList:
        print(each)
    print()

    #print("\033[34mmemPairList: \033[0m")
    #for each in memPairList:
        #print(each)
    #print()

# ================= Finish Parameter processing phase ========================

# perform dry run
print("\n\033[4;36mPerform Dry Run!\033[0m")
process = subprocess.Popen(DryRun_Command, close_fds=True, stdout=subprocess.PIPE)
dryrunstdout, dryrunerrdata = process.communicate(timeout=subprocessTimeout)
if(process.returncode!=0 and process.returncode!=1 and process.returncode!=6 and process.returncode!=-11):
    sys.exit()
if(process.returncode==1):
    exceptionFlag=0
    try:
        dryrun_context_strings = dryrunerrdata.decode("utf-8")
        if ": command not found" in dryrun_context_strings:
            print(dryrun_context_strings)
            exceptionFlag=1
    except:
        print("An exception occurred in dry run")
        pass
    if exceptionFlag == 1:
        sys.exit()

# set up shared memory (put it here is important)
ADDR = setup_share_memroy()
memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(0)), sizeof(c_uint))

# Get the number of threads and the number of key points per thread

P = c_ulonglong(0)
A = c_uint(0)
B = c_uint(0)
T = c_uint(0)
kpNumArray = (c_uint*SHARE_THREAD_NUM)(0)
kpYieldArray = (c_uint*SHARE_ARRAY_SIZE)(0)
kpLocArray = (c_uint*SHARE_ARRAY_SIZE)(0)
kpOrderArray = (c_uint*SHARE_ARRAY_SIZE)(0)

get_info_from_share_memory(P,A,B,T,kpNumArray,None,None,None)
Period = P.value
N = A.value
if N > SHARE_THREAD_NUM:
    print("Too many threads...")
    sys.exit(1)
M = B.value
if M > SHARE_ARRAY_SIZE:
    print("Too many scheduling points")
    sys.exit(1)
TupleFirst = T.value

zero_in_KP = zero_num(kpNumArray, kpMaxNumArray, N)

# update kpMaxNumArray
for i in range(0, N + zero_in_KP):
    if kpNumArray[i] > kpMaxNumArray[i]:
        kpMaxNumArray[i] = kpNumArray[i]

# print_Info_from_shm(N, M, None, kpNumArray, None, None, None, [], None, zero_in_KP, True) # Only use for debug

# reproduce a certain interleavings if provided "-r"
if TaskReproduce == 1:
    try:
        with open (reproduceFile,"rb") as f:
            first_line_b = f.readline()  # take first line
            first_line = str(first_line_b, encoding = "utf8")
            pattern_list = literal_eval(first_line) # 通过 literal_eval 这个函数，将str类型的列表转换成类型为list的真正的列表类型

            threadNum = len(pattern_list)
            KPNum = len(pattern_list[0])
            maxYieldNum = getMaxNuminPattern(pattern_list)
            # print()
            # print("+ period:", Period)
            # print("+ threadNum:", threadNum, " threadNum:", N)
            # print("+ KPNum:", KPNum, " KPNum:", M)
            
            # write the config to shared memory
            memmove(ADDR, byref(c_ulonglong(int(Period*1.5))), sizeof(c_ulonglong)) # amplify period limit
            memmove(ADDR + sizeof(c_ulonglong), byref(c_uint(threadNum)), sizeof(c_uint))
            memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint), byref(c_uint(KPNum)), sizeof(c_uint))
            memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(maxYieldNum)), sizeof(c_uint)) # tell the program how many periods we used. The program can yield those unrealted thread to the last period
            memmove_pattern_list(pattern_list)
      
        print("\n\033[4;36mPerform Reproduction!\033[0m")
        process = subprocess.Popen(DBDS_Command, close_fds=True)
        process.communicate()
        sys.exit()
                    
    except IOError:
        print("Failed to open the target reproduce file.")
        sys.exit()

# report warning if there are too many Key Points or Threads
if N > SHARE_THREAD_NUM or M * (N + zero_in_KP) > SHARE_ARRAY_SIZE:
    print("ERROR: Too many Key Points or Threads.")
    print("N = ", N, "M = ", M)
    sys.exit(1)

# create output folder for saveing the error interleavings
folder_name = ""
if '/' in args[0]:
    folder_name = "out_" + args[0].split('/')[-1]
else:
    folder_name = "out_" + args[0]

fi = 1
while (os.path.exists(folder_name + "_" + str(fi))):
    fi = fi + 1

folder_name = folder_name + "_" + str(fi)
os.makedirs(folder_name+"/"+"Errors")
os.makedirs(folder_name+"/"+"DiffResult")
os.makedirs(folder_name+"/"+"Timeouts")

# run the interleaving for yield pattern [0, 0, 0, 0, ..., 0, 1, 1, 1, ..., 1]
# ZeroPattern = [[0]*M]*N # worng
ZeroPattern = [[row for col in range(M)] for row in range(N)]
for each in ZeroPattern:
    for i in range(1,len(each)):
        each[i] = 0
memmove_pattern_list(ZeroPattern)

returnNormal = 0
PRE_DBDS_Command = copy.deepcopy(DBDS_Command)
PRE_DBDS_Command[4] = PRE_DBDS_Command[4].replace("report_bugs=1","report_bugs=0")
while returnNormal < 3:
    
    if returnNormal == 0:
        print("\n\033[4;36mPerform DBDS Run with default system scheduling!\033[0m")
    else:
        print("\n\033[4;36mPerform DBDS Run again due to increasing number of Key Points!\033[0m")

    memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(N-1)), sizeof(c_uint)) # tell the program how many periods we used. The program can yield those unrealted thread to the last period
    process = subprocess.Popen(PRE_DBDS_Command, close_fds=True)
    process.communicate()
    
    # get more info from share memory
    get_info_from_share_memory(P,A,B,T,kpNumArray,kpYieldArray,kpLocArray,kpOrderArray)

    # update kpMaxNumArray
    for i in range(0, N + zero_in_KP):
        if returnNormal == 0 and kpNumArray[i] >=1:
            kpMaxNumArray[i] = kpNumArray[i]
        else:
            if kpNumArray[i] > kpMaxNumArray[i]:
                kpMaxNumArray[i] = kpNumArray[i]

    if (process.returncode == 0 or process.returncode == 1 or process.returncode == 6 or process.returncode == -11): #and A.value != 1 and A.value != 0:
        if A.value > N or B.value > M or check_and_update_kpNumMaxArray(kpNumArray, zero_in_KP):
            if A.value > N:
                N = A.value
            if B.value > M:
                M = B.value
            check_and_update_kpNumMaxArray(kpNumArray, zero_in_KP) # This function would not be executed in the if condiction
            returnNormal = returnNormal + 1
        else:
            if N != 0 and N != 1:
                returnNormal = 4
            else:
                print("\033[31m\tCan not catch multithread mode (Thread = " + str(N) + ")\033[0m")
                returnNormal = returnNormal + 1
    else:
        returnNormal = returnNormal + 1
    
    if returnNormal == 3:
        print("There seems to be some errors when executing the default schedule.")
        print("Please execute it again.")
        sys.exit(1)
    elif returnNormal == 4:
        break

# save the parentArray
for i in range(0, A.value + zero_in_KP):
    parentArray[i] = kpNumArray[i]
parentArrayCopy = parentArray.copy()

# print info into the screen
print("\n--------------------------------------")
print("Runtime:", Period)
default_coverage_hashID = calculate_coverage_hashID(kpLocArray, M * (N + zero_in_KP), kpNumArray, N, SHARE_ARRAY_SIZE)
print_Info_from_shm(N, M, TupleFirst, kpNumArray, kpYieldArray, kpLocArray, kpOrderArray, [], default_coverage_hashID, zero_in_KP, False)
print("--------------------------------------")
print("Enter 'debug' to view the debug information")
if skipEnter == 0:
    input_from_user = input("Press Enter to continue...\n")
    if input_from_user == "debug" or input_from_user == "DEBUG" or input_from_user == "Debug":
        print("--------------------------------------")
        print_Info_from_shm(N, M, TupleFirst, kpNumArray, kpYieldArray, kpLocArray, kpOrderArray, [], default_coverage_hashID, zero_in_KP, True)
        input("Press Enter to continue...")
else:
    pass

DBDS_stage = 1 # record the stage in our testing, init 1
waited_to_explore = OrderedDict() # save those interleaving that more key points are covered
waited_to_explore_save = OrderedDict() # save those interleaving that more key points are covered
prefix = []

VarModeFlag = -1 # if VarModeFlag == 0, the next if statement will return true
directInterList = []  # [inter,useful_kp_num_list, useful_kp_index_list] use for false branch
directInterList_save = []
CurdirectInter =  []
printSecondFlag = 0 # used to display the second reading

if LoadMemInfoFile == 0 or varNumConsidered > len(memGroupList) or len(memGroupList) < 3 or  M < 8: # len(memPairList) < 3 or memPairConsidered > len(memPairList)
    print("Consider all variables")
    VarModeFlag = 0

elif varNumConsidered !=0:
    print("Consider " + str(varNumConsidered) + " variables")
    VarModeFlag = 1

    # get combinations from memGroup
    for eachComb in combinations([n for n in range(0, len(memGroupList))], varNumConsidered):
        # save each Comb into a tmpList
        tmpLocList = []
        for eachIndex in eachComb:
            for eachRWSO in memGroupList[eachIndex][1]:
                tmpLocList.append(eachRWSO)
            for eachRWSO in memGroupList[eachIndex][2]:
                tmpLocList.append(eachRWSO)
            for eachRWSO in memGroupList[eachIndex][3]:
                tmpLocList.append(eachRWSO)
        tmpLocList = sorted(set(tmpLocList), key=tmpLocList.index)

        # find Corresponding Hash Value
        tmpHashList = []
        for eachKp in tmpLocList:
            for eachSo in pureSoList:
                if eachSo[0] == eachKp:
                    tmpHashList.append(eachSo[3])

        # mark useful KP at this round
        useful_kp_num_list = [0] * (N + zero_in_KP)
        useful_kp_index_list = []
        for eachHashID in tmpHashList:
            for i in range(0, M * (N + zero_in_KP)):
                if str(kpLocArray[i]) == eachHashID:
                    useful_kp_num_list[int(i/M)] = useful_kp_num_list[int(i/M)] + 1
                    useful_kp_index_list.append(i)
        useful_kp_index_list = sorted(useful_kp_index_list)
        
        # if useful_kp_num_list contains lots of zero, no use
        how_many_zero = 0
        for each in useful_kp_num_list:
            if each != 0:
                how_many_zero = how_many_zero + 1
        if how_many_zero < 2:
            continue

        # print(useful_kp_num_list)
        # print(useful_kp_index_list)

        printSecondFlag = printSecondFlag + 1
        if printSecondFlag == 50:
            printSecondFlag = 0
            print("Generating permutation combinations...")

        # save these inter into directInterList
        directInterList.append([useful_kp_num_list, useful_kp_index_list, tmpLocList])

        # copy directInterList
        directInterList_save = copy.deepcopy(directInterList)
else:
    VarModeFlag = 2
    print("to be continue...")

print("\n\033[4;36mStart Testing!\033[0m")

N_after_DryRun = N
kpMaxNumArray_after_DryRun = copy.deepcopy(kpMaxNumArray)
period_limit = bugDepth + N - 1

for iterPeriod in range(N_after_DryRun, period_limit+1):

    # Iterative Period Bounding
    if VarModeFlag == 0 or (iterPeriod - N_after_DryRun + 1 < 2):
        
        MList = []
        for i in range(0, N_after_DryRun + zero_in_KP):
            MList.append(kpMaxNumArray_after_DryRun[i])
        try:
            scheduler = SBPSched(N_after_DryRun + zero_in_KP, MList, iterPeriod)
        except:
            print("There is no schedule to satisfy under the constraint:", MList, ", ", iterPeriod)
            scheduler = None
            pass
    else:
        if directInterList != []:
            CurdirectInter = directInterList.pop()
            if CurdirectInter != []:
                useful_kp_num_list = CurdirectInter[0]
                print("\033[4;36mExploration of these KP:\033[0m", CurdirectInter[2])
                try:
                    scheduler = SBPSched(N + zero_num(useful_kp_num_list, [0]*SHARE_THREAD_NUM, N), useful_kp_num_list, iterPeriod)
                except:
                    print("There is no schedule to satisfy under the constraint:", useful_kp_num_list, ", ", iterPeriod)
                    scheduler = None
                    pass
            else:
                break
        else:
            break
    
    if scheduler != None and scheduler.get_schedule() == None:
        break
    parentArray = parentArrayCopy # restore parentArray
    waited_to_explore = waited_to_explore_save # restore waited_to_explore in every exploration of different bug depth
    memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint)*2, byref(c_uint(iterPeriod-1)), sizeof(c_uint)) # tell the program how many periods we used. The program can yield those unrealted thread to the last period
    print("Targeting bugs that bug depth =", iterPeriod - N_after_DryRun + 1, ". Iterate for", iterPeriod, "periods")
    
    reach_runs_limit = 0
    while True:

        if scheduler != None:

            if scheduler.get_schedule() == None:
                break
        
            for inter in scheduler:

                if DBDS_stage == 1 and iterPeriod - N_after_DryRun + 1 >= 4 and full_deep_run == 0: # for deep bug, explore interesting prefix is enough
                    break

                # Filtering redundant scheduling
                # if is_redundant(inter):
                    # continue

                rounds = rounds + 1
                if not prefix == []:
                    if is_redundant_with_prefix(inter, prefix):
                        rounds = rounds - 1
                        continue
                    print("\033[4;36mtest", str(format(rounds,"0>4"))+" for prefix " + str(prefix) + ":\033[0m ", end="")
                else:
                    print("\033[4;36mtest", str(format(rounds,"0>4"))+":\033[0m ", end="")

                if runs_limit != 0 and rounds > runs_limit:
                    reach_runs_limit = 1
                    break
            
                if VarModeFlag == 0 or (iterPeriod - N_after_DryRun + 1 < 2):
                    # for each interleaving, get the yield pattern
                    pattern = scheduler.get_yield_pattern()
                    # print inter into screen
                    print(inter)
                    # align pattern list (filled with zero)
                    filled_with_zero(pattern, M)
                else:
                    # for each interleaving, get the yield pattern
                    if CurdirectInter != []:
                        simplicityPattern = scheduler.get_yield_pattern()

                        pattern = [[0] * M for i in range(N + zero_in_KP)]
                        patternList = []
                        for each in simplicityPattern:
                            patternList = patternList + each
                        
                        # Fill the simplified pattern to the complete pattern
                        useful_kp_index_list = CurdirectInter[1]
                        for i in range(0, len(useful_kp_index_list)):
                            pattern[int(useful_kp_index_list[i]/M)][useful_kp_index_list[i] - int(useful_kp_index_list[i]/M)*M] = patternList[i]
                        # print pattern into screen
                        print(inter) # print(simplicityPattern)
                        
                    else: # same with VarModeFlag == 0
                        # for each interleaving, get the yield pattern
                        pattern = scheduler.get_yield_pattern()
                        # print inter into screen
                        print(inter)
                        # align pattern list (filled with zero)
                        filled_with_zero(pattern, M)

                # write the config to shared memory
                # memmove(ADDR, byref(c_ulonglong(Period)), sizeof(c_ulonglong))
                memmove(ADDR + sizeof(c_ulonglong), byref(c_uint(N)), sizeof(c_uint))
                memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint), byref(c_uint(M)), sizeof(c_uint)) #必需用最大的M
                
                memmove_pattern_list(pattern)
                
                # create subprocess according to the value of check_STDOUT and check_STDERR
                process = create_DBDS_subprocess(check_STDOUT, check_STDERR)

                try:
                    # join subprocess
                    if recordERR:
                        stdoutdata, stderrdata = process.communicate(timeout=subprocessTimeout)
                    else:
                        process.communicate(timeout=subprocessTimeout)
                
                    # get info from share memory
                    get_info_from_share_memory(None,A,B,T,kpNumArray,kpYieldArray,kpLocArray,kpOrderArray)

                    # update NMKPNUMA and rerun
                    check_and_update_kpNumMaxArray(kpNumArray, zero_in_KP)
                    
                    # The array for storing KP is too small. Reset the array size and perform the test again
                    while A.value > N or B.value > M:

                        if A.value > N:
                            N = A.value
                        if B.value > M:
                            M = B.value
                        
                        print("\033[4;36mtest", str(format(rounds,"0>4"))+" (retest) \033[0m ")
                        process = create_DBDS_subprocess(check_STDOUT, check_STDERR)
                        if recordERR:
                            stdoutdata, stderrdata = process.communicate(timeout=subprocessTimeout)
                        else:
                            process.communicate(timeout=subprocessTimeout)
                        get_info_from_share_memory(None,A,B,T,kpNumArray,kpYieldArray,kpLocArray,kpOrderArray)

                    parentArrayCopy = parentArray.copy()
                    coverFlag = 0
                    if new_max_kpNumArray(kpNumArray, parentArray, zero_in_KP):
                        coverFlag = 1
                    parentArray = parentArrayCopy # restore parentArray

                    # if new coverage, we save the prefix of interleaving
                    coverage_hashID = calculate_coverage_hashID(kpLocArray, M * (N + zero_in_KP), kpNumArray, N, SHARE_ARRAY_SIZE)
                                    
                    if DBDS_stage == 2 and coverage_hashID in waited_to_explore_save:
                        coverFlag = 0
                    if coverage_hashID == default_coverage_hashID:
                        coverFlag = 0
                    if coverFlag == 1 :
                        kpNumList = []
                        for i in range(0, A.value + zero_in_KP):
                            kpNumList.append(kpNumArray[i])
                        # This is a replacement. A sequence with the same hash value that appears later replaces an existing sequence. So if there's anything new than your parents, replace old ones with the same hash value.
                        add_to_explore_dict(waited_to_explore, coverage_hashID, scheduler.get_schedule().copy(), pattern.copy(), A.value, B.value, kpNumList.copy(), scheduler.get_prefix().copy())
                        add_to_explore_dict(waited_to_explore_save, coverage_hashID, scheduler.get_schedule().copy(), pattern.copy(), A.value, B.value, kpNumList.copy(), scheduler.get_prefix().copy())
                    # save the error message
                    if recordERR:
                        #print("[DEBUG] process.returncode = ", process.returncode)
                        record_error_message(process, folder_name, stdoutdata, stderrdata, pattern, rounds)

                    # [debug] print info from share memory
                    if DebugInfo:
                        prefixPrint = scheduler.get_prefix()
                        print_Info_from_shm(A.value, B.value, T.value, kpNumArray, kpYieldArray, kpLocArray, kpOrderArray, prefixPrint, coverage_hashID, zero_in_KP, False)
                
                except subprocess.TimeoutExpired:
                    # process.kill()
                    # process.terminate()
                    subprocess.check_call(["sudo", "kill", str(process.pid)])
                    #os.waitpid(process.pid, 0)
                    if recordERR:
                        record_timeout_message(folder_name, pattern)
                
                except Exception as e:
                    print("\033[34m\tUnknown Exception" + "\033[0m")
                    print(e)
                    pass

        # if cannot find next interleaving
        if DBDS_stage == 1:
            if VarModeFlag == 0 or (iterPeriod - N_after_DryRun + 1 < 2):
                waited_to_explore_save = copy.deepcopy(waited_to_explore)
                DBDS_stage = 2
            else:
                if directInterList != []:
                    CurdirectInter = directInterList.pop()
                    useful_kp_num_list = CurdirectInter[0]
                    print("\033[4;36mExploration of these KP:\033[0m", CurdirectInter[2])
                    try:
                        scheduler = SBPSched(N, useful_kp_num_list, iterPeriod)
                    except:
                        print("There is no schedule to satisfy under the constraint in stage 1:", MList, ", ", iterPeriod)
                        scheduler = None
                        pass
                else:
                    CurdirectInter = []
                    directInterList = copy.deepcopy(directInterList_save)
                    DBDS_stage = 2

        if DBDS_stage == 2:
            
            if (iterPeriod - N_after_DryRun + 1 < 2): # bug depth == 0 no need to use prefix
                DBDS_stage = 1
                break

            if (no_prefix_run == 1): 
                DBDS_stage = 1
                break

            while_flag = 0
            while waited_to_explore:
                while_flag = 1
                popItem = waited_to_explore.popitem(last=False)
                tempL = popItem[1]
                prefix = tempL[5] # keep only the prefix of parent interleaving
                tmpMList = []
                parentArrayCopy = parentArray.copy()
                parentArray = [0]*SHARE_THREAD_NUM
                for i in range(0, tempL[2]): # range(0, A.value)
                    tmpMList.append(tempL[4][i])
                    parentArray[i] = tempL[4][i]
                try:    
                    scheduler = SBPSched(tempL[2], tmpMList, iterPeriod, prefix)
                except:
                    print("There is no schedule to satisfy under the constraint in stage 2:", MList, ", ", iterPeriod)
                    scheduler = None
                    continue
                break

            if while_flag == 0:
                prefix = []
                DBDS_stage = 1
                break
    
    if reach_runs_limit == 1:
        break


print("\033[4;36mEnd Testing!\n\033[0m")

print("\033[1;35m")
print('Total Error Interleavings:',total_errors_interleavings[0])
print('Total Timeouts Interleavings:',total_timeouts_interleavings[0])
print(len(statusL), 'status found:')
print("\t",statusL)
print(len(rlts), 'results found:')
for each in rlts:
    print("\t",each)
print('-' * 50)
print('\tLast New Find\t\tTotal')
print('Round\t{0}\t\t\t{1}'.format(lastRound, rounds))
print('Time\t' + formateTime(lastTime - startTime), end = "")
print('\t\t' + formateTime(time.time() - startTime))
print("\033[0m")
exit()
